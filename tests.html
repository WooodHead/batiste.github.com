<html>
<head>
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="reset.css" type="text/css">
<link rel="stylesheet" href="like.css" type="text/css">
<script src="like.js"></script>
</head>

<h1>Like.js - CSS classes for style and behavior</h1>

<p>Like.js is a micro framework that implements an event driven model using behavioral CSS classes.</p>

<h2>Why?</h2>

<p>Because the behavior of similar HTML elements within a Web application will vary,
a way to diffenciate those elements is required. CSS classes are a natural fit for the task.</p>

<p>The idea is to force the user to think of a prefixed (like-) CSS class for every new behavior.
This convention comes with some benefits:</p>

<ul>
  <li>Context specific event binding is discouraged: The behavior definition is declared in an external JavaScript file
      when behavior usage stays in the document. This is a form of separation of concern.</li>
  <li>By reading the HTML, you can see which elements have a behavior defined. Nothing can happen
      without class prefixed by <em>like-</em>.</li>
  <li>Removing or adding a behavior is as simple as adding/removing the <em>like-</em> CSS class .</li>
  <li>Events are automatically handled by a central event delegation dispatcher.</li>
  <li>By not tying any events to specific elements on the page (event delegation), inserting new elements is easy.</li>
</ul>

<h2>How to use</h2>

<p>Like.js expose an unique object in the global scope: <strong>like</strong>. The most important method is <em>like.a</em>.
   It is used to define a behavior associated with a CSS class. eg:</p>

<pre>like.a("popup", "click", function(dom, event){...});</pre>

<p>As soon as the <strong>popup</strong> behavior is declared, all elements in the page with CSS class 
<strong>like-popup</strong> will respond to the <strong>click</strong> event. 
The callback function is called with the DOM element as a first parameter and the Event as the second.</p>

<div class="snippet">

  <h2>Example 1: a positive number behavior</h2>

  <div class="html">
<label>A positive number <input class="like-positive-number" value="wrong" /></label><br>
<label id="inserted"></label>
  </div>

  <h3>HTML</h3>
  <pre class="html-view"></pre>
    
  <script>
like.a("positive-number", "keyup change likeInit likeInsert", function(dom, event) {
  var v = parseInt(dom.value, 10);
  if(v < 0 || isNaN(v)) {
    v = 0;
  }
  if(dom.value!=v) {
    dom.value = v;
  }
});

like.insert(like.byId("inserted"), 'Same but inserted dynamically <input class="like-positive-number" value="-100" />');
  </script>
  <h3>Code</h3>
  <pre class="code-view"></pre>


  <h3>Notes</h3>

  <p>There is 2 pseudo events in like.js.</p>

  <ul>
  <li><strong>likeInit</strong> is triggered immediatly after the behavior as been declared. This is the reason why the first
    input doesn't have the <strong>wrong</strong> value.</li>
  <li>
 <strong>likeInsert</strong> on the other hand is triggered when new behavioral DOM elements
     are inserted in the document using <strong>like.insert(dom, html)</strong>.
  </li>
  </ul>

</div>


<div class="snippet">

  <h2>Example 2: event bubbling</h2>

  <div class="html">
<span class="like-bubble">
<span class="like-bubble">
<span class="like-bubble pop">pop
<span class="like-bubble">
</span>
</span>
</span>
</span>
  </div>

  <h3>HTML</h3>
  <pre class="html-view"></pre>
    
  <script>
like.a("bubble", "mouseover mouseout likeInit", {
    mouseover: function(dom, event) {
      this.addClass("bubble-over");
      if(this.hasClass("pop")) {
        return false;
      }
    },
    mouseout: function(dom, event) {
      this.removeClass("bubble-over");
      if(this.hasClass("pop")) {
        return false;
      }
    }
});
  </script>
  <h3>Code</h3>
  <pre class="code-view"></pre>

  <h3>Notes</h3>

  <ol>
  <li>
    The keyword <em>this</em> in the context of the callback is a <em>Like object</em>. DOM operations apply
    on the current DOM element when applicable.
  </li>
  <li>like.js, like jQuery, will interupt the bubbling when <strong>false</strong> 
     is returned in the callback.</li>
  <li>
    You can dispatch events to different handler by passing 
    an object of callables instead of a single callback function.  
  </li>
  </ol>

</div>


<div class="snippet">

  <h2 id="ex3">Example 3: a more complex example</h2>

  <div class="html">
<form method="get" action="" class="like-not-submit">
<table class="like-sum-table">
<thead>
<tr><th>Quantity</th><th>Price</th><th>Total</th></tr>
</thead>
<tbody>
  <tr class="like-product-line">
    <td><input type="text" class="like-positive-number" value="1"></td>
    <td><span class="price">20.80</span>$</td>
    <td><span class="total"></span>$</td>
  </tr>
  <tr class="like-product-line">
    <td><input type="text" class="like-positive-number" value="2"></td>
    <td><span class="price">15.20</span>$</td>
    <td><span class="total"></span>$</td>
  </tr>
  <tr>
    <td>Grand Total</td>
    <td></td>
    <td><span class="grand-total"></span>$</td>
  </tr>
</tbody></table>
</form>
</div>

  <h3>HTML</h3>
  <pre class="html-view"></pre>
    
  <script>
function roundCent(v) { return Math.round(v * 100) / 100 }
var money = 120;

like.a("product-line", "likeInit change keyup", function(dom, event) {
  var quantity = this.byClass("like-positive-number")[0].value;
  if(quantity=="") {
    quantity = 0;
  }
  var price = parseFloat(this.byClass("price")[0].innerHTML, 10);
  this.byClass("total")[0].innerHTML = roundCent(price * parseInt(quantity, 10));
});

like.a("sum-table", "likeInit change keyup", function(dom, event) {
  var grandTotal = 0; 
  this.iterate(this.byClass("total"), function(el) {
    grandTotal += parseFloat(el.innerHTML, 10);
  });
  this.byClass("grand-total")[0].innerHTML = roundCent(grandTotal);
});


  </script>
  <h3>Code</h3>
  <pre class="code-view"></pre>



</div>

</table>
<script>
function safe(h) {
  return h.replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/^\s+|\s+$/g, '');
}

like.iterate(like.byClass("snippet"), function(dom) {
  var code = like.byTag("script", dom)[0].innerHTML;
  like.byClass("code-view", dom)[0].innerHTML = safe(code);
  var html = like.byClass("html", dom)[0].innerHTML;
  like.byClass("html-view", dom)[0].innerHTML = safe(html);
});

</script>
